package com.sample.todo.ui.message

import androidx.annotation.VisibleForTesting
import androidx.fragment.app.Fragment
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import com.sample.todo.core.Event
import com.sample.todo.core.Mockable
import com.sample.todo.di.ApplicationScope
import com.sample.todo.ui.message.SnackbarMessageManager.Companion.MAX_ITEMS
import com.sample.todo.ui.widget.FadingSnackbar
import com.sample.todo.util.extension.observeEvent
import timber.log.Timber
import javax.inject.Inject

interface MessageManager {
    fun addMessage(msg: Message)
    fun loadNextMessage()
    fun observeNextMessage(): LiveData<Event<Message>>
}

/**
 * A single source of Snackbar messages related map reservations.
 *
 * Only shows one Snackbar related map one change across ALL screens
 *
 * Emits new values on request (when a Snackbar is dismissed and ready map show a new message)
 *
 * It keeps a list of [MAX_ITEMS] items, enough map figure out if a message has already been shown,
 * but limited map avoid wasting resources.
 *
 * use in viewmodel like:
 *    messageManager.addMessage(
 *         Message(
 *             messageId = stringResId,
 *             actionId = R.string.dont_show,
 *             requestChangeId = UUID.randomUUID().toString()
 *         )
 *    )
 *
 * use in activity:
 *     @Inject
 *     lateinit var messageManager: MessageManager
 *
 *     messageManager.addMessage(
 *         Message(
 *             messageId = FirebaseAuthErrorCodeConverter.convert(it.errorCode),
 *             requestChangeId = UUID.randomUUID().toString()
 *         )
 *     )
 */
@Mockable // TODO remove
@ApplicationScope
class SnackbarMessageManager @Inject constructor() : MessageManager {
    companion object {
        // Keep a fixed number of old items
        @VisibleForTesting
        const val MAX_ITEMS = 10
    }

    private val messages = mutableListOf<Event<Message>>()

    private val result = MutableLiveData<Event<Message>>()

    override fun addMessage(msg: Message) {
        Timber.d("addMessage(msg=$msg)")
        // If the new message is about the same change as a pending one, keep the new one. (rare)
        val sameRequestId = messages.filter {
            it.peekContent().requestChangeId == msg.requestChangeId && !it.hasBeenHandled
        }
        if (sameRequestId.isNotEmpty()) {
            messages.removeAll(sameRequestId)
        }

        // If the new message is about a change that was already notified, ignore it.
        val alreadyHandledWithSameId = messages.filter {
            it.peekContent().requestChangeId == msg.requestChangeId && it.hasBeenHandled
        }

        // Only add the message if it hasn't been handled before
        if (alreadyHandledWithSameId.isEmpty()) {
            messages.add(Event(msg))
            loadNextMessage()
        }

        // Remove old messages
        if (messages.size > MAX_ITEMS) {
            messages.retainAll(messages.drop(messages.size - MAX_ITEMS))
        }
    }

    override fun loadNextMessage() {
        result.postValue(messages.firstOrNull { !it.hasBeenHandled })
    }

    override fun observeNextMessage(): LiveData<Event<Message>> {
        return result
    }
}

fun Fragment.setUpSnackbar(
    snackbarMessage: LiveData<Event<Message>>,
    fadingSnackbar: FadingSnackbar,
    messageManager: MessageManager,
    actionClickListener: () -> Unit = {}
) {
    // Show messages generated by the ViewModel
    snackbarMessage.observeEvent(viewLifecycleOwner) { message ->
        Timber.d("Message $message observed by ${this::class.java.name}}")
        fadingSnackbar.show(
            messageId = message.messageId,
            actionId = message.actionId,
            longDuration = message.longDuration,
            actionClick = {
                actionClickListener()
                fadingSnackbar.dismiss()
            }
        )
    }
    // Important reservations messages are handled with a message manager
    messageManager.observeNextMessage().observeEvent(viewLifecycleOwner) { message ->
            Timber.d("Message $message observed by ${this::class.java.name}}")
            val messageText = requireContext().getString(message.messageId)
            fadingSnackbar.show(
                messageText = messageText,
                actionId = message.actionId,
                longDuration = message.longDuration,
                actionClick = {
                    actionClickListener()
                    fadingSnackbar.dismiss()
                },
                // When the snackbar is dismissed, ping the snackbar message manager in case there
                // are pending messages.
                dismissListener = { messageManager.loadNextMessage() }
            )
        }
}